<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Working with big data in R and Python</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ff803dae0bae9edb91fb3cd2582d8e33.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="assets/styles.css">
</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#data-frames-in-r-and-python" id="toc-data-frames-in-r-and-python" class="nav-link active" data-scroll-target="#data-frames-in-r-and-python">1 Data frames in R and Python</a>
  <ul class="collapse">
  <li><a href="#data-frames-in-r" id="toc-data-frames-in-r" class="nav-link" data-scroll-target="#data-frames-in-r">1.1 Data frames in R</a></li>
  <li><a href="#using-sql-syntax-with-r-data-frames-sqldf" id="toc-using-sql-syntax-with-r-data-frames-sqldf" class="nav-link" data-scroll-target="#using-sql-syntax-with-r-data-frames-sqldf">1.2 Using SQL syntax with R data frames: <code>sqldf</code></a></li>
  <li><a href="#data-frames-in-python" id="toc-data-frames-in-python" class="nav-link" data-scroll-target="#data-frames-in-python">1.3 Data frames in Python</a></li>
  <li><a href="#distributed-data-frames-in-dask-in-python" id="toc-distributed-data-frames-in-dask-in-python" class="nav-link" data-scroll-target="#distributed-data-frames-in-dask-in-python">1.4 Distributed data frames in Dask in Python</a></li>
  </ul></li>
  <li><a href="#dplyr-in-r" id="toc-dplyr-in-r" class="nav-link" data-scroll-target="#dplyr-in-r">2 dplyr in R</a>
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">2.1 Overview</a></li>
  <li><a href="#piping" id="toc-piping" class="nav-link" data-scroll-target="#piping">2.2 Piping</a></li>
  <li><a href="#functionality" id="toc-functionality" class="nav-link" data-scroll-target="#functionality">2.3 Functionality</a></li>
  <li><a href="#cautionary-notes" id="toc-cautionary-notes" class="nav-link" data-scroll-target="#cautionary-notes">2.4 Cautionary notes</a></li>
  <li><a href="#dplyr-with-sql-and-databases" id="toc-dplyr-with-sql-and-databases" class="nav-link" data-scroll-target="#dplyr-with-sql-and-databases">2.5 dplyr with SQL and databases</a></li>
  </ul></li>
  <li><a href="#manipulating-datasets-quickly-in-memory" id="toc-manipulating-datasets-quickly-in-memory" class="nav-link" data-scroll-target="#manipulating-datasets-quickly-in-memory">3 Manipulating datasets quickly in memory</a>
  <ul class="collapse">
  <li><a href="#data.table-in-r" id="toc-data.table-in-r" class="nav-link" data-scroll-target="#data.table-in-r">3.1 <code>data.table</code> in R</a></li>
  <li><a href="#using-dplyr-syntax-with-data.table-in-r" id="toc-using-dplyr-syntax-with-data.table-in-r" class="nav-link" data-scroll-target="#using-dplyr-syntax-with-data.table-in-r">3.2 Using dplyr syntax with data.table in R</a></li>
  <li><a href="#polars-dataframes-in-python" id="toc-polars-dataframes-in-python" class="nav-link" data-scroll-target="#polars-dataframes-in-python">3.3 Polars dataframes in Python</a></li>
  <li><a href="#duckdb" id="toc-duckdb" class="nav-link" data-scroll-target="#duckdb">3.4 DuckDB</a></li>
  </ul></li>
  <li><a href="#working-with-large-datasets-on-disk" id="toc-working-with-large-datasets-on-disk" class="nav-link" data-scroll-target="#working-with-large-datasets-on-disk">4 Working with large datasets on disk</a>
  <ul class="collapse">
  <li><a href="#arrow" id="toc-arrow" class="nav-link" data-scroll-target="#arrow">4.1 Arrow</a></li>
  <li><a href="#duckdb-1" id="toc-duckdb-1" class="nav-link" data-scroll-target="#duckdb-1">4.2 DuckDB</a></li>
  <li><a href="#fst" id="toc-fst" class="nav-link" data-scroll-target="#fst">4.3 fst</a></li>
  <li><a href="#additional-packages-in-r-ff-laf-bigmemory" id="toc-additional-packages-in-r-ff-laf-bigmemory" class="nav-link" data-scroll-target="#additional-packages-in-r-ff-laf-bigmemory">4.4 Additional packages in R (ff, LaF, bigmemory)</a></li>
  <li><a href="#strategies-in-python" id="toc-strategies-in-python" class="nav-link" data-scroll-target="#strategies-in-python">4.5 Strategies in Python</a></li>
  <li><a href="#online-batch-processing-of-data-in-r-and-python" id="toc-online-batch-processing-of-data-in-r-and-python" class="nav-link" data-scroll-target="#online-batch-processing-of-data-in-r-and-python">4.6 Online (batch) processing of data in R and Python</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Working with big data in R and Python</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This section aims to provide an overview of working with large datasets in R and (to a lesser extent) Python. Given the scope of topics, this is not meant to be a detailed treatment of each topic.</p>
<p>We’ll start with a refresher on data frames in R and Python and some discussion of the <em>dplyr</em> package, whose standard operations are similar to using SQL syntax. Note that what is referred to as split-apply-combine functionality in dplyr in R and in pandas in Python is the same concept as the use of SQL’s GROUP BY combined with aggregation operations such as MIN, MAX, AVG, COUNT.</p>
<p>The CSV files for the 2016 Stack Overflow data and the space-delimited files for the Wikipedia traffic data used in the examples below can be obtained <a href="http://www.stat.berkeley.edu/share/paciorek/tutorial-databases-data.zip">here</a>.</p>
<section id="data-frames-in-r-and-python" class="level2">
<h2 class="anchored" data-anchor-id="data-frames-in-r-and-python">1 Data frames in R and Python</h2>
<section id="data-frames-in-r" class="level3">
<h3 class="anchored" data-anchor-id="data-frames-in-r">1.1 Data frames in R</h3>
<p>A data frame in R is essentially the same as a table in SQL. The notion of a data frame has been essential to the success of R and its existence inspired Python’s Pandas package.</p>
<p>R’s data frames are stored in memory, but there are now packages (such as dplyr with an SQL backend, <code>arrow</code>, <code>SparkR</code> and <code>h2o</code>) that allow you to treat an external data source as if it were an actual R data frame, using familiar syntax to operate on the data frame.</p>
<p>This tutorial assumes you’re familiar with basic data frame functionality in R or Python, so I won’t go into more details here.</p>
<p>dplyr, which will be discussed later, allows you to operate on data frames using functionality that is similar to SQL, in particular selecting columns, filtering rows, aggregation operations on subsets, and joining multiple data frames.</p>
<p>But base R syntax can be used for all of these operations too. Here’s the base R syntax corresponding to SQL’s SELECT, WHERE, GROUP BY, and JOIN functionality.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>users <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>questions <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'questions-2016.csv'</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>users[ , <span class="fu">c</span>(<span class="st">'userid'</span>, <span class="st">'upvotes'</span>)] <span class="co"># select columns</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>users[users<span class="sc">$</span>upvotes <span class="sc">&gt;</span> <span class="dv">10000</span>, ]   <span class="co"># filter by row (i.e., SQL WHERE)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">aggregate</span>(upvotes <span class="sc">~</span> age, <span class="at">data =</span> users, <span class="at">FUN =</span> median) <span class="co"># group by (i.e., aggregation)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>joined <span class="ot">&lt;-</span> <span class="fu">merge</span>(users, questions, <span class="at">by.x =</span> <span class="st">'userid'</span>, <span class="at">by.y =</span> <span class="st">'ownerid'</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">all.x =</span> <span class="cn">FALSE</span>, <span class="at">all.y =</span> <span class="cn">FALSE</span>)  <span class="co"># inner join</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="using-sql-syntax-with-r-data-frames-sqldf" class="level3">
<h3 class="anchored" data-anchor-id="using-sql-syntax-with-r-data-frames-sqldf">1.2 Using SQL syntax with R data frames: <code>sqldf</code></h3>
<p>The <em>sqldf</em> package provides the ability to use SQL queries on R data frames (via <code>sqldf</code>) and on-the-fly when reading from CSV files (via <code>read.csv.sql</code>). The latter can help you avoid reading in the entire dataset into memory in R if you just need a subset of it.</p>
<p>The basic sequence of operations that happens is that the data frame (if using <code>sqldf</code>) or the file (if using <code>read.csv.sql</code>) is read temporarily into a database and then the requested query is performed on the database, returning the result as a regular R data frame. So you might find things to be a bit slow because of the time involved in creating the database.</p>
<p>The following illustrates usage but the <code>read.csv.sql</code> part of the code won’t work in practice on this particular example input file, because sqldf regards quotes as part of the text and not as delineating fields. The CSVs for the Stack Overflow data all have quotes distinguishing fields because there are commas within some fields.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(sqldf)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="do">## sqldf</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>users <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>,<span class="st">'users-2016.csv'</span>))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>oldUsers <span class="ot">&lt;-</span> <span class="fu">sqldf</span>(<span class="st">"select * from users where age &gt; 75"</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="do">## read.csv.sql with data read into an in-memory database</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>oldUsers <span class="ot">&lt;-</span> <span class="fu">read.csv.sql</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>),  </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">sql =</span> <span class="st">"select * from file where age &gt; 75"</span>,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">dbname =</span> <span class="cn">NULL</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="do">## read.csv.sql with data read into temporary database on disk</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>oldUsers <span class="ot">&lt;-</span> <span class="fu">read.csv.sql</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>),  </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>      <span class="at">sql =</span> <span class="st">"select * from file where age &gt; 75"</span>,</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      <span class="at">dbname =</span> <span class="fu">tempfile</span>(), <span class="at">header =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And note that one can use <code>sqldf::read.csv.sql</code> to avoid reading all the data in from disk.</p>
</section>
<section id="data-frames-in-python" class="level3">
<h3 class="anchored" data-anchor-id="data-frames-in-python">1.3 Data frames in Python</h3>
<p>The Pandas package has nice functionality for doing dataset manipulations akin to SQL queries including group by/aggregation operations, using a data structure called a DataFrame inspired by R’s data frames. Furthermore, Pandas was designed from the start for computational efficiency, in contrast to standard data frames in R (but see below for newer R functionality that is much more efficient).</p>
<p>Here are some examples:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>users <span class="op">=</span> pd.read_csv(os.path.join(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>questions <span class="op">=</span> pd.read_csv(os.path.join(<span class="st">'data'</span>, <span class="st">'questions-2016.csv'</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(users)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>users[[<span class="st">'userid'</span>, <span class="st">'upvotes'</span>]]   <span class="co"># select columns         </span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>users[users.upvotes <span class="op">&gt;</span> <span class="dv">10000</span>]   <span class="co"># filter by row (i.e., sql WHERE)</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># group by (i.e., aggregation)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>users.groupby(<span class="st">'age'</span>)[<span class="st">'upvotes'</span>].agg({<span class="st">'med'</span>: <span class="st">'median'</span>, <span class="st">'avg'</span>: <span class="st">'mean'</span>}) </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>joined <span class="op">=</span> pd.merge(users, questions, how<span class="op">=</span> <span class="st">'inner'</span>, left_on<span class="op">=</span> <span class="st">'userid'</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        right_on <span class="op">=</span> <span class="st">'ownerid'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><a href="https://docs.pola.rs/user-guide">Polars</a> is a newer dataframe package that provides a Python interface and is designed to be fast.</p>
<p>Here are some examples:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> polars <span class="im">as</span> pl</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>users <span class="op">=</span> pl.read_csv(os.path.join(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>tags <span class="op">=</span> pl.read_csv(os.path.join(<span class="st">'data'</span>, <span class="st">'questions_tags-2016.csv'</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>questions <span class="op">=</span> pl.read_csv(os.path.join(<span class="st">'data'</span>, <span class="st">'questions-2016.csv'</span>))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(users)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>users.select(pl.col(<span class="st">'userid'</span>,<span class="st">'upvotes'</span>))   <span class="co"># select columns         </span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>users.<span class="bu">filter</span>(pl.col(<span class="st">'upvotes'</span>) <span class="op">&gt;</span> <span class="dv">10000</span>)    <span class="co"># filter by row (i.e., sql WHERE)</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># group by (i.e., aggregation)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>tags.groupby(<span class="st">'tag'</span>).agg(</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">'*'</span>).count().alias(<span class="st">'n'</span>))</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>tags.groupby(<span class="st">'tag'</span>).agg(</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        pl.col(<span class="st">'*'</span>).count().alias(<span class="st">'n'</span>)).sort(<span class="st">'n'</span>, descending<span class="op">=</span><span class="va">True</span>).head(<span class="dv">8</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">## Users userid got read in as an integer but Questions ownerid as string.</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>users.schema</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>users <span class="op">=</span> pl.read_csv(os.path.join(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>), dtypes <span class="op">=</span> {<span class="st">'userid'</span>: <span class="bu">str</span>})</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>joined <span class="op">=</span> users.join(questions, how<span class="op">=</span> <span class="st">'inner'</span>, left_on<span class="op">=</span> <span class="st">'userid'</span>,</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        right_on <span class="op">=</span> <span class="st">'ownerid'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s a <a href="./polars-vs-pandas.py">further example</a> that compares Pandas and Polars, building off of <a href="https://www.r-bloggers.com/2024/02/why-pandas-feels-clunky-when-coming-from-r/?utm_source=phpList&amp;utm_medium=email&amp;utm_campaign=R-bloggers-daily&amp;utm_content=HTML#google_vignette">this blog post</a> comparing R’s dplyr to Pandas. As illustrated in the example and above, I think the Polars interface (API) is easier to read and use than that of Pandas.</p>
</section>
<section id="distributed-data-frames-in-dask-in-python" class="level3">
<h3 class="anchored" data-anchor-id="distributed-data-frames-in-dask-in-python">1.4 Distributed data frames in Dask in Python</h3>
<p>The Dask package provides the ability to divide data frames across multiple workers (and across nodes), allowing one to handle very large datasets, as discussed in <a href="https://berkeley-scf.github.io/tutorial-dask-future/python-dask#4-dask-distributed-datastructures-and-automatic-parallel-operations-on-them">this tutorial</a>.</p>
</section>
</section>
<section id="dplyr-in-r" class="level2">
<h2 class="anchored" data-anchor-id="dplyr-in-r">2 dplyr in R</h2>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">2.1 Overview</h3>
<p>dplyr is part of the <a href="http://tidyverse.org/">tidyverse</a>, a set of R packages spearheaded by Hadley Wickham. You can think of dplyr as providing the functionality of SQL (selecting columns, filtering rows, transforming columns, aggregation, and joins) on R data frames using a clean syntax that is easier to use than base R operations.</p>
<p>There’s lots to dplyr, but here we’ll just illustrate the basic operations by analogy with SQL.</p>
<p>Here we’ll read the data in and do some basic subsetting. In reading the data in we’ll use another part of the tidyverse: the <code>readr</code> package, which provides <code>read_csv</code> as a faster version of <code>read.csv</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>users <span class="ot">&lt;-</span> readr<span class="sc">::</span><span class="fu">read_csv</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">select</span>(users, userid, displayname)  <span class="co"># select columns</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1104795       2</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">filter</span>(users, age <span class="sc">&gt;</span> <span class="dv">75</span>)             <span class="co"># filter by row (i.e., SQL WHERE)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 481  10</code></pre>
</div>
</div>
</section>
<section id="piping" class="level3">
<h3 class="anchored" data-anchor-id="piping">2.2 Piping</h3>
<p>dplyr is often combined with piping, which allows you to build up a sequence of operations (from left to right), as if you were using UNIX pipes or reading a series of instructions. Here’s a very simple example where we combine column selection and filtering in a readable way:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> users <span class="sc">%&gt;%</span> <span class="fu">select</span>(displayname, userid, age) <span class="sc">%&gt;%</span> <span class="fu">filter</span>(age <span class="sc">&gt;</span> <span class="dv">75</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="do">## Or using the new pipe operator from base R:</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> users <span class="sc">|&gt;</span> <span class="fu">select</span>(displayname, userid, age) <span class="sc">|&gt;</span> <span class="fu">filter</span>(age <span class="sc">&gt;</span> <span class="dv">75</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>What happens here is that the operations are run from left to right (except for the assignment into <code>result</code>) and the result of the left-hand side of a <code>%&gt;%</code> is passed into the right-hand side function as the first argument. So this one liner is equivalent to:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>tmp <span class="ot">&lt;-</span> <span class="fu">select</span>(users, displayname, userid, age)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>result2 <span class="ot">&lt;-</span> <span class="fu">filter</span>(tmp, age <span class="sc">&gt;</span> <span class="dv">75</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">identical</span>(result, result2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>and also equivalent to:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>result3 <span class="ot">&lt;-</span> <span class="fu">filter</span>(<span class="fu">select</span>(users, displayname, userid, age), age <span class="sc">&gt;</span> <span class="dv">75</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">identical</span>(result, result3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>We’ll use pipes in the remainder of the dplyr examples.</p>
</section>
<section id="functionality" class="level3">
<h3 class="anchored" data-anchor-id="functionality">2.3 Functionality</h3>
<p>Here’s how one can do stratified analysis with aggregation operations. In the dplyr world, this is known as split-apply-combine but in the SQL world this is just a GROUP BY with some aggregation operation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>medianVotes <span class="ot">&lt;-</span> users <span class="sc">%&gt;%</span> <span class="fu">group_by</span>(age) <span class="sc">%&gt;%</span> <span class="fu">summarize</span>(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                          <span class="at">median_upvotes =</span> <span class="fu">median</span>(upvotes),</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">median_downvotes =</span> <span class="fu">median</span>(downvotes))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(medianVotes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 3
    age median_upvotes median_downvotes
  &lt;dbl&gt;          &lt;dbl&gt;            &lt;dbl&gt;
1    13           11                  0
2    14            0.5                0
3    15            0                  0
4    16            3                  0
5    17            3                  0
6    18            3                  0</code></pre>
</div>
</div>
<p>You can also create new columns, sort, and do joins, as illustrated here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="do">## create new columns</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>users2 <span class="ot">&lt;-</span> users <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">year =</span> <span class="fu">substring</span>(creationdate, <span class="dv">1</span>, <span class="dv">4</span>),</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                           <span class="at">month =</span> <span class="fu">substring</span>(creationdate, <span class="dv">6</span>, <span class="dv">7</span>))</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="do">## sorting (here in descending (not the default) order by upvotes)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>users2 <span class="ot">&lt;-</span> users <span class="sc">%&gt;%</span> <span class="fu">arrange</span>(age, <span class="fu">desc</span>(upvotes))</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="do">## joins</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>questions <span class="ot">&lt;-</span> readr<span class="sc">::</span><span class="fu">read_csv</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'questions-2016.csv'</span>))</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>questionsOfAge <span class="ot">&lt;-</span> users <span class="sc">%&gt;%</span> <span class="fu">filter</span>(age <span class="sc">&gt;</span> <span class="dv">75</span>) <span class="sc">%&gt;%</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>               <span class="fu">inner_join</span>(questions, <span class="at">by =</span> <span class="fu">c</span>(<span class="st">"userid"</span> <span class="ot">=</span> <span class="st">"ownerid"</span>))</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(questionsOfAge)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 15
  userid creationdate.x      lastaccessdate      location    
   &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;       
1   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
2   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
3   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
4   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
5   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
6   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
# ℹ 11 more variables: reputation &lt;dbl&gt;, displayname &lt;chr&gt;,
#   upvotes &lt;dbl&gt;, downvotes &lt;dbl&gt;, age &lt;dbl&gt;, accountid &lt;dbl&gt;,
#   questionid &lt;dbl&gt;, creationdate.y &lt;dttm&gt;, score &lt;dbl&gt;,
#   viewcount &lt;dbl&gt;, title &lt;chr&gt;</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="Challenge">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Challenge
</div>
</div>
<div class="callout-body-container callout-body">
<p>Why did I first filter and then do the join, rather than the reverse?</p>
</div>
</div>
<p>The join functions include <code>inner_join</code>, <code>left_join</code>, <code>right_join</code>, <code>full_join</code>. I don’t see any cross join functionality.</p>
<p>In addition to operating directly on data frames, dplyr can also operate on databases and data.table objects as the back-end storage, as we’ll see next.</p>
</section>
<section id="cautionary-notes" class="level3">
<h3 class="anchored" data-anchor-id="cautionary-notes">2.4 Cautionary notes</h3>
<p>Note that dplyr and other packages in the tidyverse use a modified form of data frames. In some cases you may want to convert back to a standard data frame using <code>as.data.frame</code>. For example:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">as.data.frame</span>(<span class="fu">head</span>(questionsOfAge, <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  userid      creationdate.x      lastaccessdate     location
1   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
2   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
3   4668 2008-09-05 04:08:05 2017-03-13 21:19:14 Portland, OR
  reputation displayname upvotes downvotes age accountid
1     116900  Alan Storm    2143       278  97      3253
2     116900  Alan Storm    2143       278  97      3253
3     116900  Alan Storm    2143       278  97      3253
  questionid      creationdate.y score viewcount
1   34552563 2016-01-01 00:02:22     2       484
2   34597749 2016-01-04 18:46:36     5       250
3   34689333 2016-01-09 03:15:07     2       119
                                                          title
1                           PHP: Phing, Phar, and phar.readonly
2 Determine if PHP files is Running as Part of a `phar` archive
3     List of PHP Keywords that are Invalid as Class Name Parts</code></pre>
</div>
</div>
<p>Note that dplyr and other tidyverse packages use a lot of “non-standard evaluation”. In this context of non-standard evaluation, the thing to pay attention to is that the column names are not quoted. This means that one cannot use a variable to stand in for a column. So the following woudn’t work because dplyr would literally look for a variable named “colname” in the data frame. There is a <a href="https://dplyr.tidyverse.org/articles/programming.html">system for addressing this</a> but I won’t go into it further here.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="do">## this won't work because of non-standard evaluation! </span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>myfun <span class="ot">&lt;-</span> <span class="cf">function</span>(df, colname) </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(df, colname)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="fu">myfun</span>(questions, <span class="st">'age'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="dplyr-with-sql-and-databases" class="level3">
<h3 class="anchored" data-anchor-id="dplyr-with-sql-and-databases">2.5 dplyr with SQL and databases</h3>
<p>We can connect to an SQLite or Postgres database and then query it using dplyr syntax:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RSQLite)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>drv <span class="ot">&lt;-</span> <span class="fu">dbDriver</span>(<span class="st">"SQLite"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>db <span class="ot">&lt;-</span> <span class="fu">dbConnect</span>(drv, <span class="at">dbname =</span> <span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'stackoverflow-2016.db'</span>))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>users <span class="ot">&lt;-</span> <span class="fu">tbl</span>(db, <span class="st">'users'</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>highVotes <span class="ot">&lt;-</span> users <span class="sc">%&gt;%</span> <span class="fu">filter</span>(upvotes <span class="sc">&gt;</span> <span class="dv">10000</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(highVotes)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># Source:   SQL [?? x 10]
# Database: sqlite 3.47.1 [/accounts/web/public/paciorek/share/stackoverflow-2016.db]
  userid creationdate        lastaccessdate   location reputation
   &lt;int&gt; &lt;chr&gt;               &lt;chr&gt;            &lt;chr&gt;         &lt;int&gt;
1   3043 2008-08-26 13:24:14 2017-03-13 17:0… York, NE     258471
2   5987 2008-09-11 21:06:49 2017-03-13 21:2… Minneap…     188661
3   6309 2008-09-13 22:22:33 2017-03-13 21:5… France       664389
4   7552 2008-09-15 13:57:22 2017-03-13 01:1… Ottawa,…     129258
5   8745 2008-09-15 16:47:12 2017-02-25 07:5… Calgary…      11418
6  12711 2008-09-16 15:22:32 2017-03-13 21:5… Seattle…     248780
# ℹ 5 more variables: displayname &lt;chr&gt;, upvotes &lt;int&gt;,
#   downvotes &lt;int&gt;, age &lt;int&gt;, accountid &lt;int&gt;</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>dplyr uses lazy evaluation when interfacing with databases – it only does the query and return results when the results are needed (in this case when we call <code>head</code>).</p>
</div>
</div>
</section>
</section>
<section id="manipulating-datasets-quickly-in-memory" class="level2">
<h2 class="anchored" data-anchor-id="manipulating-datasets-quickly-in-memory">3 Manipulating datasets quickly in memory</h2>
<section id="data.table-in-r" class="level3">
<h3 class="anchored" data-anchor-id="data.table-in-r">3.1 <code>data.table</code> in R</h3>
<p>The <em>data.table</em> package provides a lot of functionality for fast manipulation of datasets in memory. data.table can do the standard SQL operations such as indexing, merges/joins, assignment, grouping, etc. Plus data.table objects are data frames (i.e., they inherit from data frames) so they are compatible with R code that uses data frames.</p>
<p>If you’ve got enough memory, data.table can be effective with pretty large datasets (e.g., 10s of gigabytes).</p>
<p>To illustrate without the example taking too long, we’ll only read in a subset of the Wikipedia webtraffic data.</p>
<p>Let’s read in the dataset, specifying the column classes so that fread() doesn’t have to detect what they are (which will take additional time and might cause errors). Note that we can read directly from a UNIX operation piped into R.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>colClasses <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'numeric'</span>, <span class="st">'numeric'</span>, <span class="st">'character'</span>, </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>           <span class="st">'character'</span>, <span class="st">'numeric'</span>, <span class="st">'numeric'</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>colNames <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'date'</span>, <span class="st">'hour'</span>, <span class="st">'site'</span>, <span class="st">'page'</span>, <span class="st">'count'</span>, <span class="st">'size'</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(wikiDT <span class="ot">&lt;-</span> <span class="fu">fread</span>(<span class="st">'gzip -cd data/part-0000?.gz'</span>, </span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a> <span class="at">col.names =</span> colNames, <span class="at">colClasses =</span> colClasses, <span class="at">header =</span> <span class="cn">FALSE</span>,</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a> <span class="at">quote =</span> <span class="st">""</span>))</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="do">## 30 sec. for 300 MB zipped</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s do some basic subsetting. We’ll see that setting a key (equivalent to setting an index in SQL) can improve lookup speed dramatically.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="do">## without a key (i.e., index)</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(sub <span class="ot">&lt;-</span> <span class="fu">subset</span>(wikiDT, count <span class="sc">==</span> <span class="dv">512</span>)) <span class="co"># .27 sec.</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(<span class="fu">setkey</span>(wikiDT, count , size)) <span class="co"># 3 sec.</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="do">## with a key (i.e., index)</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(sub2 <span class="ot">&lt;-</span> wikiDT[.(<span class="dv">512</span>), ]) <span class="co"># essentially instantaneous</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>data.table has a lot of functionality and can be used to do a variety of sophisticated queries and manipulations (including aggregation operations), but it has its own somewhat involved syntax and concepts. The above just scratches the surface of what you can do with it.</p>
</section>
<section id="using-dplyr-syntax-with-data.table-in-r" class="level3">
<h3 class="anchored" data-anchor-id="using-dplyr-syntax-with-data.table-in-r">3.2 Using dplyr syntax with data.table in R</h3>
<p>Rather than learning the data.table syntax, one can also use dplyr syntax with data.table objects.</p>
<p>We can use dplyr syntax directly with data table objects, illustrated here with our existing <code>wikiDT</code> data table.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(sub <span class="ot">&lt;-</span> wikiDT <span class="sc">%&gt;%</span> <span class="fu">filter</span>(count <span class="sc">==</span> <span class="dv">512</span>)) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>One can also use <code>dtplyr</code> to set use a data table as a back end for dplyr manipulations. Using <code>lazy_dt</code> allows dtplyr to do some optimization as it generates the translation from dplyr syntax to data table syntax, though this simple example doesn’t illustrate the usefulness of that.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>wikiDT2 <span class="ot">&lt;-</span> <span class="fu">lazy_dt</span>(wikiDT)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(sub <span class="ot">&lt;-</span> wikiDT2 <span class="sc">%&gt;%</span> <span class="fu">filter</span>(count <span class="sc">==</span> <span class="dv">512</span>)) <span class="co"># 0.1 sec.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally the <code>tidytable</code> package also allows you to use dplyr syntax as well as other tidyverse syntax, such as <code>tidyr</code> functions.</p>
</section>
<section id="polars-dataframes-in-python" class="level3">
<h3 class="anchored" data-anchor-id="polars-dataframes-in-python">3.3 Polars dataframes in Python</h3>
<p>As mentioned earlier, <a href="https://docs.pola.rs/user-guide">Polars</a> is a newer dataframe package that provides a Python interface, operates in memory, and is designed to be fast. It uses the Arrow columnar format. It also provides a lazy execution model like Spark or Dask that allows for automatic optimization of queries.</p>
</section>
<section id="duckdb" class="level3">
<h3 class="anchored" data-anchor-id="duckdb">3.4 DuckDB</h3>
<p>With DuckDB, you can run queries against existing R and Python data frames, collections of files in the Parquet file format and other file formats, and Arrow objects, without having to copy the data or import it into an actual database.</p>
<p>In R, use the <code>duckdb_register</code> and <code>duckdb_register_arrow</code> functions to ‘register’ the data frame or Arrow data source.</p>
<p>For Python, see the <a href="https://duckdb.org/docs/api/python/data_ingestion#dataframes-arrow-tables">example syntax in the DuckDB documentation</a> to query Pandas and Polars data frames and Arrow objects.</p>
<p>Alternatively, you can read the data from files on disk into a DuckDB database table and then run queries against the database you’ve created.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> duckdb</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> duckdb.read_parquet(<span class="st">"data/*.parquet"</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>data.to_table(<span class="st">"wikistats"</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>duckdb.sql(<span class="st">"select * from wikistats limit 5"</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>duckdb.sql(<span class="st">"select count(*) from wikistats"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="working-with-large-datasets-on-disk" class="level2">
<h2 class="anchored" data-anchor-id="working-with-large-datasets-on-disk">4 Working with large datasets on disk</h2>
<p>There are a variety of packages in R and Python that allow you to work with very large datasets on disk without loading them fully into memory. Some of these are also very good at compressing files to reduce disk storage.</p>
<p>I recommend first considering Arrow as it works well with the usual dataframe manipulations, but the other packages mentioned here may also be useful.</p>
<section id="arrow" class="level3">
<h3 class="anchored" data-anchor-id="arrow">4.1 Arrow</h3>
<p>Apache Arrow provides efficient data structures for working with data in memory, usable in R via the <code>arrow</code> package and the <code>PyArrow</code> package in Python. Data are stored by column, with values in a column stored sequentially and in such a way that one can access a specific value without reading the other values in the column (O(1) lookup).</p>
<p>In general Arrow will only read data from disk as needed, avoiding keeping the entire dataset in memory (how much has to be read depends on the file format, with the native arrow format best in this regard), which can reduce I/O and memory usage.</p>
<p>You can use Apache Arrow to read and write from datasets stored as one or (often) more files in various formats, including:</p>
<ul>
<li>parquet: a space-efficient, standard format;</li>
<li>arrow format: data are stored in the same format on disk (called the ‘feather’ format) as in memory, improving I/O speed; and</li>
<li>text/csv files.</li>
</ul>
<p>See this <a href="https://stackoverflow.com/questions/56472727/difference-between-apache-parquet-and-arrow">very useful discussion</a> of file formats, comparing the parquet and arrow formats. And note that if you’re going to be reading the data frequently off disk, storing the files in text/CSV is not a good idea as it will be much faster to read from the Parquet or Arrow formats.</p>
<p>Here’s a bit of what you can do with the <em>PyArrow</em> package for Python, illustrating working with data from a collection of Parquet files.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyarrow <span class="im">as</span> pa</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyarrow.parquet <span class="im">as</span> pq</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyarrow.dataset <span class="im">as</span> ds</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>tbl <span class="op">=</span> pq.read_table(<span class="st">"data/parquet"</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">## alternatively</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>tbl <span class="op">=</span> tbl.rename_columns([<span class="st">"date"</span>,<span class="st">"hour"</span>,<span class="st">"lang"</span>,<span class="st">"site"</span>,<span class="st">"hits"</span>,<span class="st">"size"</span>])</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> tbl.<span class="bu">filter</span>(ds.field(<span class="st">'hits'</span>) <span class="op">&gt;</span> <span class="dv">10000</span>).to_pandas()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For R, there’s a <a href="https://cran.r-project.org/web/packages/arrow/vignettes/dataset.html">nice vignette</a> covering basic usage, which involves dplyr syntax. Here’s an example of reading from a single file (at the moment, I’m not seeing how to read from multiple files):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>tbl <span class="ot">&lt;-</span> <span class="fu">read_parquet</span>(<span class="st">"data/parquet/part-00000.parquet"</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>tbl <span class="ot">&lt;-</span> <span class="fu">read_feather</span>(<span class="st">"data/arrow/part-00000.arrow"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="duckdb-1" class="level3">
<h3 class="anchored" data-anchor-id="duckdb-1">4.2 DuckDB</h3>
<p>With DuckDB, with some file formats (e.g., CSV, Parquet), you can run queries on files on disk without reading the entire dataset into memory.</p>
<p>Here’s an example in Python.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> duckdb</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>duckdb.sql(<span class="st">"select * from 'data/*.parquet' limit 5"</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>duckdb.sql(<span class="st">"select count(*) from 'data/*.parquet'"</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> duckdb.sql(<span class="st">"select * from 'data/*.parquet' limit 5"</span>).to_df()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="fst" class="level3">
<h3 class="anchored" data-anchor-id="fst">4.3 fst</h3>
<p>The <em>fst</em> package for R provides the ability to quickly read and write data frames in parallel from data stored on disk in the efficient fst format. A key feature in terms of reducing memory use is that data can be quickly accessed by column or by row (O(1) lookup), allowing one to easily subset the data when reading, rather than reading the entire dataset into memory, which is what would otherwise happen.</p>
<p>Here’s an example, starting by reading data (some of the Wikipedia traffic data, 2.3 GB of data) into an initial data frame in R (which might defeat the purpose if the dataset size is too big to fit in memory).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="do">## read in Wikistats data</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>wikiDF <span class="ot">&lt;-</span> readr<span class="sc">::</span><span class="fu">read_table</span>(<span class="at">file =</span> <span class="fu">pipe</span>(<span class="st">"gzip -cd data/part-0000?.gz"</span>),</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">col_names =</span> <span class="fu">c</span>(<span class="st">'day'</span>,<span class="st">'hour'</span>,<span class="st">'language'</span>,<span class="st">'site'</span>,<span class="st">'hits'</span>,<span class="st">'size'</span>),</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">col_types =</span> <span class="fu">c</span>(<span class="st">'nnccnn'</span>))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(<span class="fu">write_fst</span>(wikiDF, <span class="fu">file.path</span>(<span class="st">'/tmp'</span>, <span class="st">'data.fst'</span>)))  <span class="do">## 8.9 seconds</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The size of the compressed file is 790 MB based on the default compression, but one can choose different compression levels.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(wikiDF <span class="ot">&lt;-</span> <span class="fu">read_fst</span>(<span class="fu">file.path</span>(<span class="st">'/tmp'</span>,<span class="st">'data.fst'</span>)))  <span class="do">## 8.4 seconds</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The 8 seconds to read the data compares to 55 seconds to read the data from the gzipped files via a connection using <code>readr::read_table</code> and 29 seconds via <code>data.table::fread</code>.</p>
</section>
<section id="additional-packages-in-r-ff-laf-bigmemory" class="level3">
<h3 class="anchored" data-anchor-id="additional-packages-in-r-ff-laf-bigmemory">4.4 Additional packages in R (ff, LaF, bigmemory)</h3>
<section id="ff" class="level4">
<h4 class="anchored" data-anchor-id="ff">4.4.1 ff</h4>
<p>ff stores datasets in columnar format, with one file per column, on disk, so is not limited by memory (with the caveat below). It then provides fast access to the dataset from R.</p>
<p>To create the disk-based ff dataset, you’ll need to first read in the data from its original home. Note the arguments are similar to those for <code>read.table</code> and <code>read.csv</code>. <code>read.table.ffdf</code> reads the data in chunks.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ff)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>colClasses <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'numeric'</span>,<span class="st">'numeric'</span>,<span class="st">'character'</span>, <span class="st">'character'</span>,<span class="st">'numeric'</span>,<span class="st">'numeric'</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>colClasses[colClasses <span class="sc">==</span> <span class="st">'character'</span>] <span class="ot">&lt;-</span> <span class="st">'factor'</span>  <span class="co"># 'character' not allowed in ff</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="do">## read in Wikistats data; this will take a while.</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>wikiff <span class="ot">&lt;-</span> <span class="fu">read.table.ffdf</span>(<span class="at">file =</span> <span class="fu">pipe</span>(<span class="st">"gzip -cd data/part-0000?.gz"</span>),</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">colClasses =</span> colClasses, <span class="at">sep =</span> <span class="st">' '</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, one can save the ff dataset into permanent storage on disk that can be much more quickly loaded than the original reading of the data above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(<span class="fu">ffsave</span>(wikiff, <span class="at">file =</span> <span class="st">'wikistats'</span>))   <span class="do">## 80 sec.</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="fu">rm</span>(wikiff)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s how one loads the dataset back in.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(<span class="fu">ffload</span>(<span class="st">'wikistats'</span>))  <span class="do">## 20 sec.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the above operations, we wrote a copy of the file in the ff binary format that can be read more quickly back into R than the original reading of the CSV using <code>ffsave</code> and <code>ffload</code>. Also note the reduced size of the binary format file compared to the original CSV. It’s good to be aware of where the binary ff file is stored given that for large datasets, it will be large. With ff (I think bigmemory is different in how it handles this) it appears to be stored in <code>/tmp</code> in an R temporary directory. Note that as we work with large files we need to be more aware of the filesystem, making sure in this case that /tmp has enough space.</p>
<p>To use ff effectively, you want to use functions designed to manipulate ff objects; otherwise R will convert the ff dataset into a standard data frame and defeat the purpose as this will put the entire dataset in memory. You can look at the ff and ffbase packages to see what functions are available using <code>library(help = ff)</code> and <code>library(help = ffbase)</code>. Notice that there is an <code>merge.ff</code> function for joins. Here we use the ff-specific table function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table.ff</span>(wikiff<span class="sc">$</span>hour)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="miscellanea" class="level5">
<h5 class="anchored" data-anchor-id="miscellanea">Miscellanea</h5>
<p>Note that a copy of an ff object appears to be a shallow copy: if you modify the copy it will change the data in the original object.</p>
<p>Note that <code>ff</code> stores factor levels <em>in memory</em>, so if one has many factor levels, that can be a limitation. Furthermore, character columns are not allowed, so one is forced to use factors. Thus with textual data or the like, one can easily run into this limitation. With the Wikistats data, this is a big problem.</p>
<p>Also, I’ve encountered problems when there are more than about 1000 columns because each column is a separate file and there can be limitations in R on how many files it has open at once.</p>
</section>
</section>
<section id="laf-package" class="level4">
<h4 class="anchored" data-anchor-id="laf-package">4.4.2 LaF package</h4>
<p>The LaF package is designed to quickly read in data from CSV and FWF (fixed-width format) input files, efficiently handling cases where you only want some of the rows or columns. It requires unzipped text files as input, so one can’t unzip input files on the fly via piping.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>colClasses <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'numeric'</span>,<span class="st">'numeric'</span>,<span class="st">'character'</span>, <span class="st">'character'</span>,<span class="st">'numeric'</span>,<span class="st">'numeric'</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>colNames <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'date'</span>, <span class="st">'hour'</span>, <span class="st">'site'</span>, <span class="st">'page'</span>, <span class="st">'count'</span>, <span class="st">'size'</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="do">## read in Wikistats data</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>datLaF <span class="ot">&lt;-</span> <span class="fu">laf_open_csv</span>(<span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'part-00000.txt'</span>), <span class="at">sep =</span> <span class="st">' '</span>,</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>       <span class="at">column_types =</span> colClasses, <span class="at">column_names =</span> colNames)  <span class="do">## returns immediately</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> datLaf[dat<span class="sc">$</span>count[] <span class="sc">==</span> <span class="dv">635</span>,]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If you run this you’ll see that the <code>laf_open_csv</code> took no time, indicating LaF is using lazy evaluation.</p>
</section>
<section id="bigmemory-for-matrices" class="level4">
<h4 class="anchored" data-anchor-id="bigmemory-for-matrices">4.4.3 bigmemory for matrices</h4>
<p><code>bigmemory</code> is similar to ff in providing the ability to load datasets into R without having them in memory, but rather stored in clever ways on disk that allow for fast access. bigmemory provides a <code>big.matrix</code> class, so it appears to be limited to datasets with a single type for all the variables. However, one nice feature is that one can use <code>big.matrix</code> objects with foreach (one of R’s parallelization tools) without passing a copy of the matrix to each worker. Rather the workers can access the matrix stored on disk.</p>
<p>The <code>biglm</code> package provides the ability to fit linear models and GLMs to big datasets, with integration with ff and bigmemory.</p>
</section>
</section>
<section id="strategies-in-python" class="level3">
<h3 class="anchored" data-anchor-id="strategies-in-python">4.5 Strategies in Python</h3>
<p>Python provides a variety of packages and approaches you can use to avoid reading large datasets fully into memory. Here is a brief overview of a few approaches:</p>
<ul>
<li>Use the <a href="https://berkeley-scf.github.io/tutorial-dask-future/python-dask#4-dask-distributed-datastructures-and-automatic-parallel-operations-on-them">Dask package</a> to break up datasets into chunks. Dask processes the data in chunks, so one often doesn’t need a lot of memory, even just on one machine.</li>
<li>Use <code>numpy.load</code> with the <code>mmap_mode</code> argument to access a numpy array (stored in a .npy file) on disk via memory mapping, reading only the pieces of the array that you need into memory, as discussed <a href="https://numpy.org/doc/stable/reference/generated/numpy.load.html">here</a>.</li>
</ul>
<p>See <a href="https://pythonspeed.com/articles/mmap-vs-zarr-hdf5">here</a> for more discussion of accessing data on disk from Python.</p>
</section>
<section id="online-batch-processing-of-data-in-r-and-python" class="level3">
<h3 class="anchored" data-anchor-id="online-batch-processing-of-data-in-r-and-python">4.6 Online (batch) processing of data in R and Python</h3>
<p>Another approach is to manually process the data in batches, only reading in chunks of data that can fit in memory before doing some computation or writing back out to disk and then reading in the next chunk. When taking this approach, you want to ensure that the code you are using will be able to skip directly to the point in the file where it should read the next chunk of data from (randomly accessing memory) rather than reading all the data up to the point of interest and simply discarding the initial data.</p>
<p>Not surprisingly there is a ton more functionality than shown below (in both Python and R) for reading chunks from files as well as skipping ahead in a file via a file connection or stream.</p>
<section id="online-processing-in-r" class="level4">
<h4 class="anchored" data-anchor-id="online-processing-in-r">4.6.1 Online processing in R</h4>
<p>In R, various input functions can read in a subset of a file or can skip ahead. In general the critical step is to use a <em>connection</em> rather than directly opening the file, as this will allow one to efficiently read the data in in chunks.</p>
<p>I’ve put these in separate chunks as a reminder that for more accurate time comparisons they should be run in separate R sessions as there are some caching effects (though it’s surprising that closing R has an effect as I would think the file would be cached by the OS regardless).</p>
<p>First we’ll see that skipping ahead when not using a connection is costly – R needs to read all the earlier rows before getting to the data of interest:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>fn <span class="ot">&lt;-</span> <span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'questions-2016.csv'</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat1 <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(fn, <span class="at">nrows =</span> <span class="dv">100000</span>, <span class="at">header =</span> <span class="cn">TRUE</span>))  <span class="co"># 0.3 sec.</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat2 <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(fn, <span class="at">nrows =</span> <span class="dv">100000</span>, <span class="at">skip =</span> <span class="dv">100001</span>, <span class="at">header =</span> <span class="cn">FALSE</span>)) <span class="co"># 0.5 sec.</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat3 <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(fn, <span class="at">nrows =</span> <span class="dv">1</span>, <span class="at">skip =</span> <span class="dv">100001</span>, <span class="at">header =</span> <span class="cn">FALSE</span>)) <span class="co"># 0.15 sec.</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat4 <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(fn, <span class="at">nrows =</span> <span class="dv">100000</span>, <span class="at">skip =</span> <span class="dv">1000001</span>, <span class="at">header =</span> <span class="cn">FALSE</span>)) <span class="co"># 3.7 sec.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we use a connection, this cost is avoided (although there is still a cost to skipping ahead compared to reading in chunks, picking up where the last chunk left off):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>fn <span class="ot">&lt;-</span> <span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'questions-2016.csv'</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>con <span class="ot">&lt;-</span> <span class="fu">file</span>(fn, <span class="at">open =</span> <span class="st">'r'</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat1c <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(con, <span class="at">nrows =</span> <span class="dv">100000</span>, <span class="at">header =</span> <span class="cn">TRUE</span>)) <span class="co"># 0.3 sec.</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat2c <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(con, <span class="at">nrows =</span> <span class="dv">100000</span>, <span class="at">header =</span> <span class="cn">FALSE</span>)) <span class="co"># 0.3 sec.</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat3c <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(con, <span class="at">nrows =</span> <span class="dv">1</span>, <span class="at">header =</span> <span class="cn">FALSE</span>)) <span class="co"># .001 sec.</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat5c <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(con, <span class="at">nrows =</span> <span class="dv">1</span>, <span class="at">skip =</span> <span class="dv">100000</span>, <span class="at">header =</span> <span class="cn">FALSE</span>)) <span class="co"># .15 sec</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You can use <code>gzfile</code>, <code>bzfile</code>, <code>url</code>, and <code>pipe</code> to open connections to zipped files, files on the internet, and inputs processed through UNIX-style piping.</p>
<p><code>read_csv</code> is generally somewhat faster and seems to be able to skip ahead efficiently even though it is not using a connection (which surprises me given that with a CSV file you don’t know how big each line is so one would think one needs to process through each line in some fashion).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(readr)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>fn <span class="ot">&lt;-</span> <span class="fu">file.path</span>(<span class="st">'data'</span>, <span class="st">'questions-2016.csv'</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat1r <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(fn, <span class="at">n_max =</span> <span class="dv">100000</span>, <span class="at">col_names =</span> <span class="cn">TRUE</span>))   <span class="co"># 0.4 sec.</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat2r <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(fn, <span class="at">n_max =</span> <span class="dv">100000</span>, <span class="at">skip =</span> <span class="dv">100001</span>, <span class="at">col_names =</span> <span class="cn">FALSE</span>)) <span class="co"># 0.13 sec</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat3r <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(fn, <span class="at">n_max =</span> <span class="dv">1</span>, <span class="at">skip =</span> <span class="dv">200001</span>, <span class="at">col_names =</span> <span class="cn">FALSE</span>)) <span class="co"># 0.07 sec</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(dat4r <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(fn, <span class="at">n_max =</span> <span class="dv">100000</span>, <span class="at">skip =</span> <span class="dv">1000001</span>, <span class="at">col_names =</span> <span class="cn">FALSE</span>)) <span class="co"># 0.18 sec</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that <code>read_csv</code> can handle zipped inputs, but does not handle a standard text file connection.</p>
</section>
<section id="online-processing-in-python" class="level4">
<h4 class="anchored" data-anchor-id="online-processing-in-python">4.6.2 Online processing in Python</h4>
<p>Pandas’ <code>read_csv</code> has similar functionality in terms of reading a fixed number of rows and skipping rows, and it can decompress zipped files on the fly.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> timeit</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>fn <span class="op">=</span> os.path.join(<span class="st">'data'</span>, <span class="st">'users-2016.csv'</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co">## here's the approach I'd recommend, as it's what 'chunksize' is intended for</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> timeit.default_timer()</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>chunks <span class="op">=</span> pd.read_csv(fn, chunksize <span class="op">=</span> <span class="dv">100000</span>, header <span class="op">=</span> <span class="dv">0</span>) <span class="co"># 0.003 sec.</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>elapsed <span class="op">=</span> timeit.default_timer() <span class="op">-</span> start_time</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>elapsed</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(chunks)</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a><span class="co">## read first chunk</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> timeit.default_timer()</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>dat1c <span class="op">=</span> chunks.get_chunk()  </span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>elapsed <span class="op">=</span> timeit.default_timer() <span class="op">-</span> start_time</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>elapsed  <span class="co"># 0.2 sec.</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="co">## read next chunk</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> timeit.default_timer()</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>dat2c <span class="op">=</span> chunks.get_chunk()  <span class="co"># 0.25 sec.</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>elapsed <span class="op">=</span> timeit.default_timer() <span class="op">-</span> start_time</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>elapsed  <span class="co"># 0.2 sec.</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a><span class="co">## this also works but is less elegant</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> timeit.default_timer()</span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>dat1 <span class="op">=</span> pd.read_csv(fn, header <span class="op">=</span> <span class="dv">0</span>, nrows <span class="op">=</span> <span class="dv">100000</span>)  </span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>elapsed <span class="op">=</span> timeit.default_timer() <span class="op">-</span> start_time</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>elapsed  <span class="co"># 0.3 sec.</span></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>start_time <span class="op">=</span> timeit.default_timer()</span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>dat2 <span class="op">=</span> pd.read_csv(fn, nrows <span class="op">=</span> <span class="dv">100000</span>, header <span class="op">=</span> <span class="va">None</span>, skiprows<span class="op">=</span><span class="dv">100001</span>)  </span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>elapsed <span class="op">=</span> timeit.default_timer() <span class="op">-</span> start_time</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>elapsed  <span class="co"># 0.3 sec.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/computing\.stat\.berkeley\.edu\/tutorial-databases");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>